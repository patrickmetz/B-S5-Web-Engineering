<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ü 6.2</title>

    <script>
        class Graph {
            _neighborSetsMap = new Map();

            constructor(...edges) {
                for (const edge of edges) {
                    for (const vertexName of edge) {
                        this.addVertex(vertexName);
                    }
                }

                for (const edge of edges) {
                    const [vertexNameA, vertexNameB] = edge;
                    this.addEdge(vertexNameA, vertexNameB);
                }
            }

            addVertex(vertex) {
                if (this._neighborSetsMap.get(vertex) === undefined) {
                    this._neighborSetsMap.set(vertex, new Set());
                }
            }

            addEdge(vertexNameA, vertexNameB) {
                // swap A with B, to revert the relation, to get iterating right
                this._neighborSetsMap.get(vertexNameB).add(vertexNameA);
            }

            topsort() {
                let stack = [];
                let visitedMap = new Map();

                const verticeSet = this._neighborSetsMap.keys();

                // visit all vertices, one after the other
                for (const vertexName of verticeSet) {
                    if (visitedMap.get(vertexName) === undefined) {
                        this.helperFunction(vertexName, visitedMap, stack);
                    }
                }

                return stack;
            }

            helperFunction(vertexName, visitedMap, stack) {
                visitedMap.set(vertexName, true);

                const neighborNames = this._neighborSetsMap.get(vertexName);

                // first recursively visit all neighbors (children) ...
                for (const neighborName of neighborNames) {
                    if (!visitedMap.get(neighborName)) {
                        this.helperFunction(neighborName, visitedMap, stack);
                    }
                }

                // ...then this is the deepest child, and therefore sorted
                stack.push(vertexName);
            }
        }

        graph = new Graph(["d", "c"], ["c", "b"], ["b", "a"]);

        stack = graph.topsort();

        console.log("Input: graph", graph);
        console.log("Output: sorted List 1", stack);

        console.assert(stack.length === 4, 'Es müssen 4 Einträge sein.', stack);
        console.assert(stack[0] === "d", 'd muss der 1. sein.', stack);
        console.assert(stack[1] === "c", 'c muss der 2. sein.', stack);
        console.assert(stack[2] === "b", 'b muss der 3. sein.', stack);
        console.assert(stack[3] === "a", 'c muss der 4. sein.', stack);
    </script>
</head>
<body>

<h1>6.2 Topologische Iterierbarkeit</h1>
</body>
</html>