<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ü 6.2</title>

    <script>
        class Graph {
            _neighborSetsMap = new Map();

            constructor(...edges) {
                for (const edge of edges) {
                    for (const vertexName of edge) {
                        this.addVertex(vertexName);
                    }
                }

                for (const edge of edges) {
                    const [vertexNameA, vertexNameB] = edge;
                    this.addEdge(vertexNameA, vertexNameB);
                }
            }

            addVertex(vertex) {
                if (this._neighborSetsMap.get(vertex) === undefined) {
                    this._neighborSetsMap.set(vertex, new Set());
                }
            }

            addEdge(vertexNameA, vertexNameB) {
                // swap A with B, to revert the relation, to get iterating right
                this._neighborSetsMap.get(vertexNameB).add(vertexNameA);
            }

            topsort() {
                let stack = [];
                let visitedMap = new Map();
                const verticeSet = this._neighborSetsMap.keys();

                // visit all vertices, one after the other
                for (const vertexName of verticeSet) {
                    if (visitedMap.get(vertexName) === undefined) {
                        this.helperFunction(vertexName, visitedMap, stack);
                    }
                    // stack grows by one sorted vertex, at each iteration
                    // console.log("stack", iterationCount, stack[iterationCount++], stack);
                }

                return stack;
            }

            helperFunction(vertexName, visitedMap, stack) {
                visitedMap.set(vertexName, true);

                const neighborNames = this._neighborSetsMap.get(vertexName);

                // first recursively visit all neighbors (children) ...
                for (const neighborName of neighborNames) {
                    if (!visitedMap.get(neighborName)) {
                        this.helperFunction(neighborName, visitedMap, stack);
                    }
                }

                // ...then this is the deepest child, and therefore sorted
                stack.push(vertexName);
            }

            [Symbol.iterator]() {
                let stack = [];
                let visitedMap = new Map();
                const verticeSet = this._neighborSetsMap.keys();
                const that = this;

                let iterationCount = 0;

                // almost the same as topsort(), ...
                return {
                    next() {
                        // ..., but just getting one vertex at a time
                        let vertexName = verticeSet.next().value;

                        // ..., but with "if"-condition instead of "for"-loop
                        if (vertexName) {
                            if (visitedMap.get(vertexName) === undefined) {
                                that.helperFunction(vertexName, visitedMap, stack);
                            }
                        }

                        // ..., but with returning current sorted vertex
                        return {
                            value: stack[iterationCount++],
                            done: vertexName === undefined
                        }
                    }
                }
            }
        }

        graph = new Graph(["schlafen", "studieren"], ["essen", "studieren"], ["studieren", "prüfen"]);

        topSort = graph.topsort();
        topSortByIteration = [];

        for (const sortedVertex of graph) {
            topSortByIteration.push(sortedVertex);
        }

        console.log("input: graph", graph);
        console.log("output: topsort", topSort);
        console.log("output: topsort by iteration", topSortByIteration);

        for (const sort of [topSort, topSortByIteration]) {
            console.assert(sort.length === 4, 'Es müssen 4 Elemente sein.', sort.length);
            console.assert(sort[0] === "schlafen", '"schlafen" muss das 1. Element sein.', sort[0]);
            console.assert(sort[1] === "essen", '"essen" muss das 2. Element sein.', sort[1]);
            console.assert(sort[2] === "studieren", '"studieren" muss das 3. Element sein.', sort[2]);
            console.assert(sort[3] === "prüfen", '"prüfen" muss das 4. Element sein.', sort[3]);
        }
    </script>
</head>
<body>

<h1>6.2 Topologische Iterierbarkeit</h1>
</body>
</html>